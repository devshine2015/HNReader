<html><head><meta name="referrer" content="origin"></meta><link rel="stylesheet" type="text/css" href="news.css?iR71jv9Cret6gTOnjGIS"></link><link rel="shortcut icon" href="favicon.ico"></link><script type="text/javascript">
function byId(id) {
  return document.getElementById(id);
}

function vote(node) {
  var v = node.id.split(/_/);   // {'up', '123'}
  var item = v[1];

  // hide arrows
  byId('up_'   + item).style.visibility = 'hidden';
  byId('down_' + item).style.visibility = 'hidden';

  // ping server
  var ping = new Image();
  ping.src = node.href;

  return false; // cancel browser nav
} </script><title>Zero size objects | Hacker News</title></head><body><center><table id="hnmain" op="item" border="0" cellpadding="0" cellspacing="0" width="85%" bgcolor="#f6f6ef"><tr><td bgcolor="#ff6600"><table border="0" cellpadding="0" cellspacing="0" width="100%" style="padding:2px"><tr><td style="width:18px;padding-right:4px"><a href="http://www.ycombinator.com"><img src="y18.gif" width="18" height="18" style="border:1px #ffffff solid;"></img></a></td><td style="line-height:12pt; height:10px;"><span class="pagetop"><b><a href="news">Hacker News</a></b><img src="s.gif" height="1" width="10"><a href="newest">new</a> | <a href="newcomments">comments</a> | <a href="show">show</a> | <a href="ask">ask</a> | <a href="jobs">jobs</a> | <a href="submit">submit</a></span></td><td style="text-align:right;padding-right:4px;"><span class="pagetop"><a href="login?goto=item%3Fid%3D9052735">login</a></span></td></tr></table></td></tr><tr style="height:10px"></tr><tr><td><table border="0"><tr><td><center><a id="up_9052735" href="vote?for=9052735&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9052735"></span></center></td><td class="title"><span class="deadmark"></span><a href="http://www.tedunangst.com/flak/post/zero-size-objects">Zero size objects</a><span class="sitebit comhead"> (tedunangst.com)</span></td></tr><tr><td colspan="1"></td><td class="subtext"><span class="score" id="score_9052735">64 points</span> by <a href="user?id=zdw">zdw</a> <a href="item?id=9052735">11 hours ago</a>  | <a href="item?id=9052735">22 comments</a></td></tr><tr style="height:10px"></tr><tr><td></td><td><form method="post" action="comment"><input type="hidden" name="parent" value="9052735"><input type="hidden" name="goto" value="item?id=9052735"><input type="hidden" name="hmac" value="1f8747a4c8ac032da29ad6c1846245c0fe99dfcf"><textarea name="text" rows="6" cols="60" style="" placeholder=""></textarea><br><br>
<input type="submit" value="add comment"></form></td></tr></table><br><br>
<table border="0"><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9053550" href="vote?for=9053550&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9053550"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=rav">rav</a> <a href="item?id=9053550">8 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">In 2013, LWN had an article on Optimization-unsafe code [1]. Essentially, after a pointer dereference, the compiler is allowed to optimize out any NULL-pointer checks, as dereferencing a NULL pointer is undefined behavior (and the compiler may assume that never happens at runtime, thus the optimization).<p>This article, in a nutshell, points out that memcpy and friends have a similar property: Although code may ask memcpy to copy 0 bytes (which will not crash in practice if argument pointers are invalid or NULL), behavior is <i>still</i> undefined if the argument pointers source&#x2F;destination are invalid.<p>I think the article is missing an introduction, as I had no idea initially what kind of &quot;difference&quot; between the pointer&#x2F;length pairs the author was asking about.<p>[1] <a href="https://lwn.net/Articles/575563/" rel="nofollow">https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;575563&#x2F;</a></font></span><p><font size="1"><u><a href="reply?id=9053550&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9054138" href="vote?for=9054138&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054138"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=bodyfour">bodyfour</a> <a href="item?id=9054138">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Ugh.. I&#x27;m generally in favor of the recent compiler optimizations dealing with assuming undefined behavior isn&#x27;t triggered (although it has broken a lot of code that had made poor attempts at overflow checking, mine included)  I think doing it for the mem* functions is a step too far.<p>I think it really was a defect in the C standard to <i>not</i> specify behavior of calls like memcpy(NULL, NULL, 0)  It has obvious no-op semantics, and every implementation I&#x27;ve ever seen would accept it just fine.  I bet there is a lot of code out there that assumes that memcpy() and friends work in this &quot;traditional&quot; way.</font></span><p><font size="1"><u><a href="reply?id=9054138&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9054182" href="vote?for=9054182&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054182"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=marvy">marvy</a> <a href="item?id=9054182">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I agree.  In this case, writing memcpy by hand would work fine, but calling the standard memcpy is undefined.  That&#x27;s just silly.  Undefined behavior should be reserved for cases where making it defined is not easy.</font></span><p><font size="1"><u><a href="reply?id=9054182&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9054375" href="vote?for=9054375&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054375"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=bodyfour">bodyfour</a> <a href="item?id=9054375">4 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I would make a less-strict statement that &quot;Undefined behavior should be reserved for cases where there might be <i>some</i> advantage for an implementation to do it a different way.&quot;<p>For memcpy it&#x27;s never safe for it to access the byte at &quot;src+len&quot; (it could be past the end of mapped memory) nor is it safe to write to &quot;dest+len&quot;  So if len==0 it should follow that it won&#x27;t access either src[0] or dest[0].<p>The spec basically allows len==0 to be a special case for this rule, although it&#x27;s not clear what implementation would ever be able to take advantage of that.</font></span><p><font size="1"><u><a href="reply?id=9054375&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9054420" href="vote?for=9054420&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054420"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=quotemstr">quotemstr</a> <a href="item?id=9054420">4 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">These &quot;gotcha&quot; optimizations are infuriating. Whether or not they&#x27;re legal under the C standard, real-world _programmer_ mental computational models don&#x27;t include a zero-length memset magically deleting NULL checks before and after the memset call. These optimizations are compiler bugs and need to be fixed.<p>Not everything the standard permits is in fact a good idea.</font></span><p><font size="1"><u><a href="reply?id=9054420&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9054558" href="vote?for=9054558&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054558"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=chrisseaton">chrisseaton</a> <a href="item?id=9054558">3 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Why not petition to change the standard if you think it&#x27;s not ideal? If you change that then you don&#x27;t have to argue with the compiler authors.</font></span><p><font size="1"><u><a href="reply?id=9054558&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9054893" href="vote?for=9054893&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054893"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=quotemstr">quotemstr</a> <a href="item?id=9054893">1 hour ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Why not both? Compilers have much faster turnaround times than language standards, and a compiler that declines to view memset as a NULL assertion is still perfectly conforming.</font></span><p><font size="1"><u><a href="reply?id=9054893&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9054088" href="vote?for=9054088&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054088"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=barrkel">barrkel</a> <a href="item?id=9054088">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">The mentality of compiler authors writing these kinds of optimizations needs examination. Specifically, inferring value constraints based on value use, and eliminating branches on that basis, is suspect for a very simple reason: if you accept as an assumption that value constraints can be inferred from code, using undefined behaviour to eliminate a branch needs to be balanced by the fact that an alternate branch exists, and presumably the user wrote it for a reason. You can&#x27;t have your cake and eat it.<p>Technically correct is not a useful standard. Working code is. If compilers make code like this fail, it should fail very loudly, not quietly; silently eliminating null checks is not a virtue unless it is absolutely known that the null pointer use would definitely blow up otherwise. Which is not always guaranteed in practice, as the memset experiment here shows.<p>If compiler authors really want to pursue this optimization, elimination of dead code by means of detection of undefined code should result in a compilation error, because the code intent is self-contradictory.</font></span><p><font size="1"><u><a href="reply?id=9054088&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9054122" href="vote?for=9054122&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054122"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=nhaehnle">nhaehnle</a> <a href="item?id=9054122">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">It&#x27;s not that simple, because of inlining and macros.<p>Those optimizations can be used to quickly throw out unnecessary code like null-pointer checks inside inlined functions, so they <i>are</i> valuable and good to have.<p>So it&#x27;s a matter of how much energy you spend on diagnostics, which ends up a rather heuristic field and perhaps we&#x27;d just be better off focusing on better static analysis tools that are separate from or can otherwise be decoupled from compilers.</font></span><p><font size="1"><u><a href="reply?id=9054122&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9054280" href="vote?for=9054280&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054280"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=barrkel">barrkel</a> <a href="item?id=9054280">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Are we better served by fast and correct code, or faster and wrong?<p>The gain from application of an optimization needs to be compared with the time and cost of bugs introduced by the same optimization. And dead code elimination isn&#x27;t necessarily a huge win - if you&#x27;re fairly sure code is dead, you can make it cheap at the cost of being more expensive should it actually be alive (see my other comment).</font></span><p><font size="1"><u><a href="reply?id=9054280&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9054647" href="vote?for=9054647&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054647"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=kryptiskt">kryptiskt</a> <a href="item?id=9054647">3 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Unnecessary code is one thing, exploiting the presence of undefined behavior to compile something that the programmer likely didn&#x27;t want is another. It doesn&#x27;t matter much if it&#x27;s fast if it&#x27;s wrong. A good compiler shouldn&#x27;t try to read the mind of the programmer, it should complain loudly and stop. It should be free to do so, given tha leeway it has with undefined behavior.<p>And of course, the standards committee should get off their asses and define some behaviors.</font></span><p><font size="1"><u><a href="reply?id=9054647&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9054144" href="vote?for=9054144&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054144"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=TheLoneWolfling">TheLoneWolfling</a> <a href="item?id=9054144">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">One could at least throw an error &#x2F; warning in &quot;obvious&quot; cases, like this.</font></span><p><font size="1"><u><a href="reply?id=9054144&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9054126" href="vote?for=9054126&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054126"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=AgentME">AgentME</a> <a href="item?id=9054126">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Telling apart which dead code the programmer thought was meaningful and what is the result of a macro or inlined function is difficult. Using functions and macros very often causes dead branches to be added, and optimizing out dead branches is a huge performance win. The fact that some already-incorrect code incorrectly behaves after these optimizations are applied is not a good reason to stop doing an entire class of standards-compatible optimizations.</font></span><p><font size="1"><u><a href="reply?id=9054126&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9054260" href="vote?for=9054260&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054260"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=barrkel">barrkel</a> <a href="item?id=9054260">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">There&#x27;s deducing the range of a variable due to constant expression evaluation and control flow, and then there&#x27;s deducing its range because of undefined behaviour.<p>I believe this analysis is possible; taint the control flow analysis with a flag. Macro expansion and inlined functions are also not intractable; debug information requires tracking token location information all the way through to generated code, so this information can be used to apply a heuristic.<p>Dead branches don&#x27;t need to cost that much, BTW. Put the code for disfavoured basic blocks out of line with other code (so it doesn&#x27;t burn up code cache), and use hinted conditional jumps to enter them (e.g. on x86, forward conditional jumps are predicted not to be taken).</font></span><p><font size="1"><u><a href="reply?id=9054260&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9054349" href="vote?for=9054349&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054349"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=AgentME">AgentME</a> <a href="item?id=9054349">4 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">That&#x27;s assuming that apparently dead branches being removed from macros and inlined functions will not cause issues with incorrect code relying on undefined behavior.</font></span><p><font size="1"><u><a href="reply?id=9054349&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9054152" href="vote?for=9054152&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054152"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=TheLoneWolfling">TheLoneWolfling</a> <a href="item?id=9054152">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">What about by default throwing an error or warning only in cases where it is &quot;obvious&quot;? (i.e. only in cases where the check was explicitly stated, so no macros &#x2F; function boundaries &#x2F; etc)<p>Ditto, if you have an explicit block (i.e. no macros &#x2F; etc) that always causes undefined behavior, warn or throw an error by default.</font></span><p><font size="1"><u><a href="reply?id=9054152&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9054171" href="vote?for=9054171&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054171"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=zokier">zokier</a> <a href="item?id=9054171">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Yeah, lets add quirks mode to C because it wasn&#x27;t a minefield enough already!</font></span><p><font size="1"><u><a href="reply?id=9054171&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9054746" href="vote?for=9054746&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054746"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=hackbinary">hackbinary</a> <a href="item?id=9054746">2 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I saw the title, and thought it was rather philosophical:<p>How &#x27;big&#x27; is zero?  Can zero be quantified?  If it can, then how come zero divided by is zero, but anything divided by zero is undefined?<p>I think it is time for another trip out west, California, baby!</font></span><p><font size="1"><u><a href="reply?id=9054746&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9054140" href="vote?for=9054140&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054140"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=TheLoneWolfling">TheLoneWolfling</a> <a href="item?id=9054140">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">It should be possible to use a SMT solver to automatically check for code for which the -O0 version has observably different behavior than the -O3 version for some inputs to the program.<p>Though I&#x27;m not sure current SMT solvers are up to the task. (Related: I was using Sugar for something a while back, only to find it was spitting out weird error messages. Turns out it encodes integers as &lt;size of domain&gt; boolean variables, which doesn&#x27;t work particularly well for large domains - it was hitting a 4 (2?) GB limit on the size of the temporary SAT input file and choking)</font></span><p><font size="1"><u><a href="reply?id=9054140&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9053989" href="vote?for=9053989&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9053989"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=rwmj">rwmj</a> <a href="item?id=9053989">6 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">This just makes the case for a safe subset of C, like Cyclone, Clight, or the recent proposal [which I can&#x27;t find now] for changing the standard so that what&#x27;s written is closer to what&#x27;s executed.</font></span><p><font size="1"><u><a href="reply?id=9053989&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9054051" href="vote?for=9054051&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054051"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=pascal_cuoq">pascal_cuoq</a> <a href="item?id=9054051">6 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Maybe you are thinking of “Friendly C”, which is more a pledge compiler authors could take not to be too creative in their quest for improved benchmark results.<p><a href="http://blog.regehr.org/archives/1180" rel="nofollow">http:&#x2F;&#x2F;blog.regehr.org&#x2F;archives&#x2F;1180</a><p>According to the article, OpenBSD changes how GCC&#x27;s optimization options get enabled with global `-Ox` options, so OpenBSD has a “Friendly C” compiler of sort.</font></span><p><font size="1"><u><a href="reply?id=9054051&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9054224" href="vote?for=9054224&amp;dir=up&amp;goto=item%3Fid%3D9052735"><div class="votearrow" title="upvote"></div></a><span id="down_9054224"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=rwmj">rwmj</a> <a href="item?id=9054224">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Indeed I was, thank you.</font></span><p><font size="1"><u><a href="reply?id=9054224&amp;goto=item%3Fid%3D9052735">reply</a></u></font></td></tr></table></td></tr></table><br><br>
</td></tr><tr><td><img src="s.gif" height="10" width="0"><table width="100%" cellspacing="0" cellpadding="1"><tr><td bgcolor="#ff6600"></td></tr></table><br>
<center><span class="yclinks"><a href="newsguidelines.html">Guidelines</a> | <a href="newsfaq.html">FAQ</a> | <a href="mailto:hn@ycombinator.com">Support</a> | <a href="lists">Lists</a> | <a href="bookmarklet.html">Bookmarklet</a> | <a href="dmca.html">DMCA</a> | <a href="http://www.ycombinator.com/">Y Combinator</a> | <a href="http://www.ycombinator.com/apply/">Apply</a> | <a href="mailto:hn@ycombinator.com">Contact</a></span><br><br>
<form method="get" action="//hn.algolia.com/">Search: <input type="text" name="q" value="" size="17"></form></center></td></tr></table></center></body></html>