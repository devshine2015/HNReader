<html><head><meta name="referrer" content="origin"></meta><link rel="stylesheet" type="text/css" href="news.css?o5VFxVrGbflhiRux3vVp"></link><link rel="shortcut icon" href="favicon.ico"></link><script type="text/javascript">
function byId(id) {
  return document.getElementById(id);
}

function vote(node) {
  var v = node.id.split(/_/);   // {'up', '123'}
  var item = v[1];

  // hide arrows
  byId('up_'   + item).style.visibility = 'hidden';
  byId('down_' + item).style.visibility = 'hidden';

  // ping server
  var ping = new Image();
  ping.src = node.href;

  return false; // cancel browser nav
} </script><title>Why OCaml, why now? (2014) | Hacker News</title></head><body><center><table id="hnmain" op="item" border="0" cellpadding="0" cellspacing="0" width="85%" bgcolor="#f6f6ef"><tr><td bgcolor="#ff6600"><table border="0" cellpadding="0" cellspacing="0" width="100%" style="padding:2px"><tr><td style="width:18px;padding-right:4px"><a href="http://www.ycombinator.com"><img src="y18.gif" width="18" height="18" style="border:1px #ffffff solid;"></img></a></td><td style="line-height:12pt; height:10px;"><span class="pagetop"><b><a href="news">Hacker News</a></b><img src="s.gif" height="1" width="10"><a href="newest">new</a> | <a href="newcomments">comments</a> | <a href="show">show</a> | <a href="ask">ask</a> | <a href="jobs">jobs</a> | <a href="submit">submit</a></span></td><td style="text-align:right;padding-right:4px;"><span class="pagetop"><a href="login?goto=item%3Fid%3D9049467">login</a></span></td></tr></table></td></tr><tr style="height:10px"></tr><tr><td><table border="0"><tr><td><center><a id="up_9049467" href="vote?for=9049467&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9049467"></span></center></td><td class="title"><span class="deadmark"></span><a href="https://spyder.wordpress.com/2014/03/16/why-ocaml-why-now/">Why OCaml, why now? (2014)</a><span class="sitebit comhead"> (spyder.wordpress.com)</span></td></tr><tr><td colspan="1"></td><td class="subtext"><span class="score" id="score_9049467">160 points</span> by <a href="user?id=lelf">lelf</a> <a href="item?id=9049467">21 hours ago</a>  | <a href="item?id=9049467">107 comments</a></td></tr><tr style="height:10px"></tr><tr><td></td><td><form method="post" action="comment"><input type="hidden" name="parent" value="9049467"><input type="hidden" name="goto" value="item?id=9049467"><input type="hidden" name="hmac" value="670ba2a4ba4d598c34007abefc858fb759ead86e"><textarea name="text" rows="6" cols="60" style="" placeholder=""></textarea><br><br>
<input type="submit" value="add comment"></form></td></tr></table><br><br>
<table border="0"><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9051067" href="vote?for=9051067&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051067"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jonsterling">jonsterling</a> <a href="item?id=9051067">11 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Nice post! There are a lot of good reasons to use OCaml over Haskell which are more compelling than “JavaScript”, though. A few of them are:<p>1. modularity (and now that they have added generative functors à la SML, you can have true abstraction)<p>2. benign effects: in Haskell &quot;proper&quot;, you do not have effects; rather you have &quot;codes&quot; for effects, which get interpreted into effects by the RTS; this rules out the possibility of, e.g., using effects to implement a semantically pure interface. On the other hand, OCaml has <i>actual</i> effects, which can be used in an open-ended way to implement all sorts of functional interfaces.<p>3. strictness: arguments abound about whether laziness or strictness is better; for me, it comes down to the fact that with some pain, you can embed laziness in a strict language with effects, but you cannot embed full-on ML-style strictness into a language like Haskell; moreover, strictness-by-default permits <i>safe</i> uses of benign effects.<p>I&#x27;d call Haskell an expression-oriented programming language, since the types end up classifying expressions and algorithms (i.e. the particular &quot;effects&quot; you used get put into the type). Whereas I&#x27;d say (OCa)ML is a value-oriented language, since values (canonical forms) are considered separately from general expressions (canonical and non-canonical forms); moreover, implementation details don&#x27;t end up in the types, so you can really consider them to be classifying values and functions (i.e. equivalence classes of algorithms, not algorithms themselves). This is largely orthogonal from strictness vs laziness, but as soon as you add partiality in, strictness becomes the only tractable way to have canonical-form-based meaning explanations for the judgements of the theory.<p>P.S. My day job is writing Haskell. (In case the Pedagogical Brethren wish to come and &quot;correct&quot; me.)</font></span><p><font size="1"><u><a href="reply?id=9051067&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051167" href="vote?for=9051167&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051167"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=gnuvince">gnuvince</a> <a href="item?id=9051167">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Adding my own two cents:<p>- I like that with OCaml you can choose if you want your code to be functional or imperative, and both are equally well-supported.  I am writing a compiler in OCaml, and I am able to use the API described in Peyton-Jones &amp; Lester for doing pretty printing while still using imperative algorithms from the Dragon Book.  This sometimes feels like cheating, but not having to figure out how to transform imperative code into functional code while still maintaining the same complexity constraints is really nice.<p>- OCaml code is usually a lot more &quot;boring&quot; than Haskell code, which is nice when reading other people&#x27;s code.  Let me explain: I am T.A.&#x27;ing an intro to compiler class where some students use Haskell and some use OCaml.  The Haskell styles of the students varies a lot: some prefer to use point-free style, some used Parsec others AttoParsec, some passed state around manually while other use a state monad, etc.  The OCaml submissions on the other hand were a lot more homogeneous: ocamllex for the scanner, menhir for the parser, the AST definition was almost identical to mine, and the code generation was also very similar.<p>- This may just be me, but I have had less problems with opam than with cabal.  Also, the merlin tool and its integration with Emacs are really good and give me the kind of minimal, out-of-my-way IDE experience that I am looking for.</font></span><p><font size="1"><u><a href="reply?id=9051167&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051135" href="vote?for=9051135&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051135"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jordwalke">jordwalke</a> <a href="item?id=9051135">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I generally prefer programming with immutability, but I certainly appreciate the ability to use &quot;benign effects&quot; in my programs. Besides the case for performance, I have applied a strange combination of benign effects, GADTs, and functors to generate a sort of &quot;proof of type equality&quot; between two values passed into a framework, each of which are not known to the framework because they&#x27;re passed <i>into</i> the framework by two separate clients of the framework. At that point, I had the ability to reason about two values with arbitrary and potentially distinct types, as either being not the same (None), or the same Some(x, y) with x and y having the same type.<p>I have no clue if there&#x27;s a more elegant way to do this (edit: there probably is), but even I (as a n00b) was able to figure out how to do this by using benign effects. There&#x27;s only a single mutation in this library - but it was such a critical one that made everything else possible.<p>I&#x27;m curious about the reason for preferring generative functors over applicative functors. It seems like both could have valid use cases. Could you point me to a writeup that explains why you believe generative functors are superior?</font></span><p><font size="1"><u><a href="reply?id=9051135&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051172" href="vote?for=9051172&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051172"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jonsterling">jonsterling</a> <a href="item?id=9051172">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">After numerous discussions with Bob Harper (and reading Derek Dreyer&#x27;s work, who has been the biggest proponent for applicative functors), I have come to understand that there are only two compelling use-cases for applicative functors:<p>1. higher order functors.<p>2. modular type classes<p>Higher order functors are kind of cool, but IMO Standard ML does not seem to be suffering too much from the lack of them. I&#x27;m not too interested in it, since it gets super gnarly super fast, and this happens to be pretty much the main use-case for applicative functors. I suspect that most use-cases of higher order functors in OCaml could be reformulated to be first order, with a lot less monkeying around in the module system. There may be compelling use-cases though.<p>The other use-case is possibly a version of modular type classes that behaved a bit more like Haskell&#x27;s. The idea is that if functors are going to be applied automatically during elaboration to provide something like type classes, you&#x27;ll get MkWelp(S) called in multiple places, and you would prefer that any type members of the resulting structure be compatible. Applicative functors would do this.<p>I am not too convinced by this use-case, though I could see that people would find it useful.<p>In all other cases, generative functors have the correct semantics. Pretty much the whole use-case of putting abstract types in a functor is that you can then reason intensionally about them (i.e. distinguish them based on their access path). This is super useful, for instance, if you have a notion of &quot;index&quot; or something and you want to prevent yourself from using indexes from one table in another one, or something along those lines.<p>This is what the Scala people mystifyingly call &quot;path dependent types&quot;. It&#x27;s just generative abstraction.<p>So maybe it is an interesting feature to have applicative functors, but these should be added post facto, and generative functors should be the default. OCaml now supports generative functors if you add an extra () parameter; it&#x27;s strange syntax, but it&#x27;s good enough for me! :)</font></span><p><font size="1"><u><a href="reply?id=9051172&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9051282" href="vote?for=9051282&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051282"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lpw25">lpw25</a> <a href="item?id=9051282">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I think I disagree with this. Your functors should generally be pure, and for pure functors applicative is a nicer semantics.<p>Consider the case of a set implemented as a binary tree. The type of such a set should be parametrised by the type of the elements and the ordering used. With applicative functors this is the case as your set type will be `Set(O).t` where `O` is a structure containing the type and the ordering. With generative functors each individual set type is abstract -- so the type itself is not parameterised by the ordering.<p>You could consider this to be just an example of what you are calling &quot;Modular Type Classes&quot;, but there doesn&#x27;t need to be a system of implicit module parameters for it to be useful.</font></span><p><font size="1"><u><a href="reply?id=9051282&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9051334" href="vote?for=9051334&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051334"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jonsterling">jonsterling</a> <a href="item?id=9051334">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">lps25:<p>&gt; Consider the case of a set implemented as a binary tree. The type of such a set should be parametrised by the type of the elements and the ordering used. With applicative functors this is the case as your set type will be `Set(O).t` where `O` is a structure containing the type and the ordering. With generative functors each individual set type is abstract -- so the type itself is not parameterised by the ordering.<p>You make a good point about this not being strictly about type classes. But I&#x27;d say that the issue is only a problem in the presence of implicit resolution, since otherwise, you can just bind the result of the functor to a structure once and be done with it. It becomes an issue with type classes, because you don&#x27;t have the choice to share a single structure during elaboration.<p>IMO, the generative version is still better for most use-cases (pure or not), but it&#x27;s nice that you can have both in OCaml.</font></span><p><font size="1"><u><a href="reply?id=9051334&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="160"></td><td valign="top"><center><a id="up_9051869" href="vote?for=9051869&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051869"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jordwalke">jordwalke</a> <a href="item?id=9051869">4 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">&gt;&gt; since otherwise, you can just bind the result of the functor to a structure once..<p>My understanding was that of lpw25&#x27;s. I wanted to use applicative functors in the same way type classes (or OCaml&#x27;s modular implicits) would make use of them, but even without type class&#x27;s implicit resolution (explicitly specifying them). I agree there isn&#x27;t too much difference from doing the same with generative functors, but the main difference is, as you said, I would need to find a place (some appropriately accessible location in the namespace) by which to access the result of these generative functor applications, and that&#x27;s just an extra point of friction (if I understand correctly). It&#x27;s not the end of the world as you said either way because we can do either.<p>Thanks for the help, jonsterling&#x2F;lpw25.</font></span><p><font size="1"><u><a href="reply?id=9051869&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051320" href="vote?for=9051320&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051320"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=manu3000">manu3000</a> <a href="item?id=9051320">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">The first chapter of Dreyer&#x27;s thesis &quot;Understanding and Evolving the ML Module System&quot; (<a href="http://www.mpi-sws.org/~dreyer/thesis/main.pdf" rel="nofollow">http:&#x2F;&#x2F;www.mpi-sws.org&#x2F;~dreyer&#x2F;thesis&#x2F;main.pdf</a>) talks about generativity</font></span><p><font size="1"><u><a href="reply?id=9051320&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051341" href="vote?for=9051341&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051341"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=peter-fogg">peter-fogg</a> <a href="item?id=9051341">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">&gt; 2. benign effects: in Haskell &quot;proper&quot;, you do not have effects; rather you have &quot;codes&quot; for effects, which get interpreted into effects by the RTS; this rules out the possibility of, e.g., using effects to implement a semantically pure interface. On the other hand, OCaml has actual effects, which can be used in an open-ended way to implement all sorts of functional interfaces.<p>So, to be all pedantic and stuff... You&#x27;ve always got unsafePerformIO, first off. This is used in Debug.Trace (<a href="https://hackage.haskell.org/package/base-4.7.0.2/docs/src/Debug-Trace.html#trace" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;base-4.7.0.2&#x2F;docs&#x2F;src&#x2F;De...</a>) to allow printf debugging in pure code. This is also used in some Haskell libraries to provide restricted effects in monads other than IO. But if you don&#x27;t want to use unsafe* functions, you can always use ST to get direct access to mutable memory in a safe way. If you can runST within that interface, then you can present a pure interface to users.</font></span><p><font size="1"><u><a href="reply?id=9051341&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051353" href="vote?for=9051353&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051353"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jonsterling">jonsterling</a> <a href="item?id=9051353">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">1. that&#x27;s why I qualified it &quot;proper&quot;. Of course there is unsafePerformIO, but in the presence of laziness, this is <i>really unsafe</i>. as opposed to ML, where doing IO may harm your ability to reason about stuff, but it won&#x27;t be unsafe.<p>Debug.Trace is also unpredictable; actually, it&#x27;s perfectly predictable if you understand laziness, but it&#x27;s still not what&#x27;s really wanted in most cases.<p>2. ST is a single instance of an effect that can be interpreted into &quot;pure&quot; code. There are plenty of other effects that don&#x27;t work like this in Haskell, not to mention the problem of composing them together.<p>So thanks for chiming in! But what you have said is not really that different from what I have said.</font></span><p><font size="1"><u><a href="reply?id=9051353&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9051660" href="vote?for=9051660&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051660"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=tel">tel</a> <a href="item?id=9051660">6 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I would love to talk to you a little about these kinds of things. I&#x27;ve been digging more seriously into OCaml the last few weeks and would love some signposts for making the Haskell-&gt;OCaml transition.</font></span><p><font size="1"><u><a href="reply?id=9051660&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="160"></td><td valign="top"><center><a id="up_9051796" href="vote?for=9051796&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051796"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jonsterling">jonsterling</a> <a href="item?id=9051796">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Hi! Please feel free to email me at any time. I can&#x27;t promise that I will know everything you want to know (since I only know very little), but I would be happy to help with what I do know. jon [at] jonmsterling [dot] com.<p>BTW, I looked at your OCaml stuff yesterday, and it seemed pretty cool.</font></span><p><font size="1"><u><a href="reply?id=9051796&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051338" href="vote?for=9051338&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051338"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=spyder81">spyder81</a> <a href="item?id=9051338">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Thanks! (I&#x27;m the author). I focussed on JavaScript because it&#x27;s what I know, it&#x27;s my day job, and I wanted to share a bit of my research while trying to introduce AltJS to it.<p>I wasn&#x27;t (and am still not) really enough of an expert in either Haskell or OCaml to talk about other differences; including a bunch of dot points I don&#x27;t understand wouldn&#x27;t help anyone :)</font></span><p><font size="1"><u><a href="reply?id=9051338&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051812" href="vote?for=9051812&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051812"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jonsterling">jonsterling</a> <a href="item?id=9051812">5 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Hi! Thanks for writing the post. I didn&#x27;t mean to criticize you for talking about what you know; I hope I was able to help give a broader perspective on some of the other issues at hand too. :)</font></span><p><font size="1"><u><a href="reply?id=9051812&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051223" href="vote?for=9051223&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051223"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=YAYERKA">YAYERKA</a> <a href="item?id=9051223">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">&gt;1. modularity (and now that they have added generative functors à la SML, you can have true abstraction)<p>Could you share some information regarding Haskell and it&#x27;s &#x27;modularity&#x27; problem (vs. the ML family of languages). I&#x27;m fond of the way SML projects can be structured.  How are people solving this using Haskell?  Are there any interesting solutions for creating modular Haskell application&#x2F;system&#x27;s I can see today?<p>Thanks for your comment.</font></span><p><font size="1"><u><a href="reply?id=9051223&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051237" href="vote?for=9051237&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051237"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jonsterling">jonsterling</a> <a href="item?id=9051237">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">There is a weak form of modularity which can be achieved by using two parts of haskell:<p>1. hiding constructors in files
2. type classes<p>But it doesn&#x27;t really begin to approach the kind of structuring that is possible in an ML-like system. Unfortunately, the issue is very (needlessly) controversial, and I don&#x27;t think I want to get dragged into it here.<p>I&#x27;ll mention, though, that Haskell does have one form of modularity which ML doesn&#x27;t really, which is the fact that you can write algorithms separately, compose them together after the fact, and expect to get reasonable performance in most cases. This is because of two things: haskell is non-strict, and GHC has pretty good fusion. In ML, you often end up manually fusing things together in order to get good performance, so composition can be a bit more difficult.</font></span><p><font size="1"><u><a href="reply?id=9051237&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9051335" href="vote?for=9051335&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051335"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=sgeisenh">sgeisenh</a> <a href="item?id=9051335">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">&gt; I&#x27;ll mention, though, that Haskell does have one form of modularity which ML doesn&#x27;t really, which is the fact that you can write algorithms separately, compose them together after the fact, and expect to get reasonable performance in most cases.<p>I&#x27;d actually argue the opposite. MLton is one of the best whole program optimizing compilers I have ever used. There are virtually no penalties for abstraction. OCaml has a bit of trouble here, from what I&#x27;ve heard, but I&#x27;ve never personally run into serious performance problems as a result of abstraction.</font></span><p><font size="1"><u><a href="reply?id=9051335&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9051340" href="vote?for=9051340&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051340"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jonsterling">jonsterling</a> <a href="item?id=9051340">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">sgeisenh —  wow! How cool. If that is the case, than that&#x27;s awesome, and makes me very happy.</font></span><p><font size="1"><u><a href="reply?id=9051340&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051319" href="vote?for=9051319&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051319"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=codygman">codygman</a> <a href="item?id=9051319">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Awesome response, but....<p>&gt;  (In case the Pedagogical Brethren wish to come and &quot;correct&quot; me.)<p>Seems very unnecessary and is a big departure from the Haskell community I&#x27;m personally used to. On top of that, it&#x27;s not the tone I&#x27;m used to on HN for the most part either.<p>Apologies for going off topic, just felt obliged to chime in.</font></span><p><font size="1"><u><a href="reply?id=9051319&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051329" href="vote?for=9051329&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051329"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jonsterling">jonsterling</a> <a href="item?id=9051329">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Hey, sorry... You&#x27;re right, I shouldn&#x27;t have said this. Over the past few days, certain parts of the Haskell community have been particularly vicious (toward me and others), and I have been feeling a bit beleaguered. I shouldn&#x27;t have brought it here though. Cheers.</font></span><p><font size="1"><u><a href="reply?id=9051329&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9050352" href="vote?for=9050352&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050352"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=didyoucheckthe"><font color="#3c963c">didyoucheckthe</font></a> <a href="item?id=9050352">15 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">&gt; The first question I usually get ... is “Why not Haskell?”.<p>&gt; The answer is JavaScript.<p>My current favorite language for this is Elm[1]. It compiles to JS, is based on Haskell, and has a few simple differences between either[2].<p>Elm doesn&#x27;t let you use the tons of available Haskell libraries, and makes it slightly painful to integrate with JS. But it&#x27;s the coolest thing for the web so far. And here&#x27;s why:<p>It uses a completely declarative state machine to model a fully interactive and complete GUI! This is the dream React.js and Om didn&#x27;t even know they were heading towards! And yes, it is as good as it sounds.<p>[1]: <a href="http://elm-lang.org/" rel="nofollow">http:&#x2F;&#x2F;elm-lang.org&#x2F;</a><p>[2]: <a href="http://elm-lang.org/learn/FAQ.elm" rel="nofollow">http:&#x2F;&#x2F;elm-lang.org&#x2F;learn&#x2F;FAQ.elm</a><p>EDIT:<p>Also, Elm fixed Haskell&#x27;s awful syntax record name collision problem, and awesomely too!</font></span><p><font size="1"><u><a href="reply?id=9050352&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050493" href="vote?for=9050493&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050493"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jarcane">jarcane</a> <a href="item?id=9050493">14 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Purescript[1] is also gaining some traction and even has a pretty nice looking book out. [2]<p>It has some changes however; most notably it&#x27;s strictly evaluated rather than lazy, and there are differences in how it handles type variables. [3]<p>Personally though, I&#x27;ve grown more fond of F# than Haskell; I only wish the documentation for Websharper and Funscript was more solid.<p>[1] <a href="http://www.purescript.org/" rel="nofollow">http:&#x2F;&#x2F;www.purescript.org&#x2F;</a>
[2] <a href="https://leanpub.com/purescript/read" rel="nofollow">https:&#x2F;&#x2F;leanpub.com&#x2F;purescript&#x2F;read</a>
[3] <a href="https://github.com/purescript/purescript/wiki/Differences-from-Haskell" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;purescript&#x2F;purescript&#x2F;wiki&#x2F;Differences-fr...</a></font></span><p><font size="1"><u><a href="reply?id=9050493&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9050515" href="vote?for=9050515&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050515"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=didyoucheckthe"><font color="#3c963c">didyoucheckthe</font></a> <a href="item?id=9050515">14 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Elm is actually 3 things rolled into one:<p>1. an language very similar to Haskell<p>2. a set of runtime libraries<p>3. a technique for modeling a GUI as a declarative state machine<p>PureScript only competes with #1 and #2 here. Where Elm really shines is #3, which #2 helps with a lot.<p>Technically #3 could be done in any language. But it really helps to model it in such an expressive language with immutable data and no side-effects (except via Signals).</font></span><p><font size="1"><u><a href="reply?id=9050515&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9050763" href="vote?for=9050763&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050763"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=purescript">purescript</a> <a href="item?id=9050763">13 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I won&#x27;t argue that Elm does anything other than an exemplary job at #3, but it is worth noting that there are some interesting efforts to build similar functionality in PureScript libraries:<p><a href="https://github.com/paf31/purescript-thermite" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;paf31&#x2F;purescript-thermite</a><p><a href="https://github.com/kRITZCREEK/reactive-psc" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;kRITZCREEK&#x2F;reactive-psc</a><p><a href="https://github.com/bodil/purescript-signal" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;bodil&#x2F;purescript-signal</a><p><a href="https://github.com/michaelficarra/purescript-demo-mario" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;michaelficarra&#x2F;purescript-demo-mario</a><p><a href="https://github.com/mechairoi/purescript-frp-rabbit" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;mechairoi&#x2F;purescript-frp-rabbit</a><p>To me, this is the benefit of PureScript - yes, you have to do a little more work, because you don&#x27;t get these things for free from the compiler and tools, but you gain complete control over your application structure. You&#x27;re not forced to work in some ambient Signal category.</font></span><p><font size="1"><u><a href="reply?id=9050763&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9050847" href="vote?for=9050847&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050847"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lomnakkus">lomnakkus</a> <a href="item?id=9050847">12 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">You can probably implement Elm in PureScript pretty trivially, AFAICT. AFAIK Elm doesn&#x27;t have any static guarantees about lack-of-space leaks or lack-of-time leaks. Or, maybe it just lacks higher-order-signals? (Which would mostly prevent those sorts of things happening). I found Neel Krishnaswami&#x27;s papers on a static way to decide&#x2F;prevent these things statically very interesting. I haven&#x27;t found any implementation of his ideas, but they seem pretty solid: <a href="http://www.cs.bham.ac.uk/~krishnan/" rel="nofollow">http:&#x2F;&#x2F;www.cs.bham.ac.uk&#x2F;~krishnan&#x2F;</a></font></span><p><font size="1"><u><a href="reply?id=9050847&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050496" href="vote?for=9050496&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050496"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=moomin">moomin</a> <a href="item?id=9050496">14 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Time to plug Kris&#x27; blog post about Haskell in the browser: <a href="http://blog.jenkster.com/2015/02/a-brief-and-partial-review-of-haskell-in-the-browser.html" rel="nofollow">http:&#x2F;&#x2F;blog.jenkster.com&#x2F;2015&#x2F;02&#x2F;a-brief-and-partial-review-...</a><p>TLDR: he thinks elm&#x27;s the most practical approach right now.</font></span><p><font size="1"><u><a href="reply?id=9050496&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050786" href="vote?for=9050786&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050786"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jordwalke">jordwalke</a> <a href="item?id=9050786">13 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Could anyone summarize how well PureScript and Elm treat sourcemaps&#x2F;debugging in the browser? For a while I thought that js_of_ocaml didn&#x27;t support sourcemaps, but it turns out, one of my dependencies wasn&#x27;t compiled with debug flag (-g) and I was able to get a pretty good sourcemaps&#x2F;debugging experience in Chrome dev tools once I fixed that issue. Is there something js_of_ocaml can learn from PureScript&#x2F;Elm&#x27;s JS compilation toolchain? Or should we look to CLJS (which I&#x27;m also really excited about) as the best example?</font></span><p><font size="1"><u><a href="reply?id=9050786&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9050846" href="vote?for=9050846&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050846"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=purescript">purescript</a> <a href="item?id=9050846">12 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I can&#x27;t really comment on source maps in Elm, but the approach in PureScript has been to generate clean, readable JS which is debuggable directly. Source maps are on the roadmap, but not really a priority right now. I haven&#x27;t heard any complaints about the ability to debug compiled PureScript yet.</font></span><p><font size="1"><u><a href="reply?id=9050846&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9051161" href="vote?for=9051161&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051161"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jordwalke">jordwalke</a> <a href="item?id=9051161">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">That&#x27;s a nice approach for debugging! If the mapping is close enough, I don&#x27;t mind reading the JS output. I&#x27;m curious about the general approach to compilation, though. It seems like a statically typed language could take advantage of the knowledge of types to generate an even more efficient version of the program that uses typed arrays and views (though, yes, it would require implementing a garbage collector unless relying on some kind of WeakMap in the JS engine).
I&#x27;ve heard of garbage collected languages compiling to LLVM which would allow Emscripten to assist you, but I&#x27;ve also heard that LLVM has a really hard time with GC languages.</font></span><p><font size="1"><u><a href="reply?id=9051161&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="160"></td><td valign="top"><center><a id="up_9051258" href="vote?for=9051258&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051258"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=purescript">purescript</a> <a href="item?id=9051258">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Right now, the translation is very direct. My basic rule of thumb is - only perform those optimizations which the user opts into. Some things are standard though, like a few inlining rules and tail call elimination, but the plan is to provide a rewrite rules engine so that the developer can be as fine-grained as they like when it comes to optimizations.</font></span><p><font size="1"><u><a href="reply?id=9051258&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051297" href="vote?for=9051297&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051297"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=spyder81">spyder81</a> <a href="item?id=9051297">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">As far as I can tell Elm is more of a GUI focused language, when I was evaluating AltJS languages I was looking for something a bit more low level. The JS and DOM bindings of js_of_ocaml were what really sold me although I didn&#x27;t mention this in the post.</font></span><p><font size="1"><u><a href="reply?id=9051297&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050735" href="vote?for=9050735&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050735"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=nicklovescode">nicklovescode</a> <a href="item?id=9050735">13 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">hey didyoucheckthe I&#x27;m working on a new programming language that I think you may be interested if you like Elm. Couldn&#x27;t find your email in your profile, but mine is cammarata.nick@gmail.com. I&#x27;d love to show you</font></span><p><font size="1"><u><a href="reply?id=9050735&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9050395" href="vote?for=9050395&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050395"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=dbpatterson">dbpatterson</a> <a href="item?id=9050395">15 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I think the author doesn&#x27;t give enough credit to things that OCaml has that Haskell doesn&#x27;t have: a powerful module system (ie, functors), polymorphic variants&#x2F;subtyping, etc.</font></span><p><font size="1"><u><a href="reply?id=9050395&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050547" href="vote?for=9050547&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050547"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jordwalke">jordwalke</a> <a href="item?id=9050547">14 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">There&#x27;s a bunch of other nice features of OCaml such as named arguments, fast compile times, strictness, c-types, and reasonable records. To achieve (some of the feature in) Elm style &quot;structural subtyping&quot; records in OCaml you use the more verbose &quot;object&quot; keyword which is just a record with row polymorphism. Most choose to stick with standard records because they compile to more efficient code.<p>I think the ML module system (in OCaml and other languages) is very powerful because it allows you to abstract and operate not only on types but also on values simultaneously. F#, Haskell, and most others lack this but it would be great if they were to officially adopt it.
OCaml is also very easy to learn and I seriously recommend Real World OCaml - it&#x27;s free online and excellent.</font></span><p><font size="1"><u><a href="reply?id=9050547&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9050836" href="vote?for=9050836&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050836"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lomnakkus">lomnakkus</a> <a href="item?id=9050836">12 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Agreed on the ML module system. It&#x27;s a damn shame that Haskell has this anemic probably-historical-accident namespacing-only module system that we&#x27;re stuck with. On the plus side, there seems to be some real impetus to implement the Backpack system, though there are still unexplored points in the design space behind Backpack, especially wrt. type classes.<p>FWIW, I think type classes are actually what make Haskell more appealing to me than O&#x27;Caml, even though O&#x27;Caml&#x27;s modules technically subsume type classes (for most purposes anyway). In practice it just gets too verbose.<p>That, and enforced purity.</font></span><p><font size="1"><u><a href="reply?id=9050836&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9050956" href="vote?for=9050956&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050956"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jordwalke">jordwalke</a> <a href="item?id=9050956">11 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">One thought on the verbosity of type classes vs. ML modules&#x2F;functors:
As a framework developer, if I have a more powerful abstraction (supposing ML functors&#x2F;modules really are more powerful), then even if abstracting is more verbose, it might result in an even better end-developer experience, if that explicitness is limited to the core internal part of the framework.<p>In other words, that verbose application of functors etc, might only need to be written once in the internals of the framework, but could enable more powerful features for users of the framework with little or no additional verbosity. This is just one thing I&#x27;ve noticed happen in a very specific case and it might not be true in general. Really learning Haskell type classes is still on my list of things to do, so please forgive me if I&#x27;ve misspoken.</font></span><p><font size="1"><u><a href="reply?id=9050956&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="160"></td><td valign="top"><center><a id="up_9050972" href="vote?for=9050972&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050972"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lomnakkus">lomnakkus</a> <a href="item?id=9050972">11 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">That was actually my main objection to modules vs. typeclasses: The burden often seemed to land on the <i>users</i> of libraries. Typeclasses are usually effortless as a user, though there may be a multitude of sins[1] hidden behind them.<p>EDIT: Don&#x27;t get me wrong, there are also advantages to being able to explcitly declare two structurally identical modules as different, but in practice I find that newtypes suffice.<p>[1] FlexibleInstances, UndecidableInstances, etc. :)</font></span><p><font size="1"><u><a href="reply?id=9050972&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051150" href="vote?for=9051150&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051150"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ufo">ufo</a> <a href="item?id=9051150">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Named arguments may be just &quot;syntax sugar&quot; but its one of the biggest things I miss from Haskell. They make library functions more consistent and they also make it much easier to write point free code because you don&#x27;t need to resort to combinators like &quot;flip&quot; or &quot;.&quot; as much.</font></span><p><font size="1"><u><a href="reply?id=9051150&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9051214" href="vote?for=9051214&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051214"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jordwalke">jordwalke</a> <a href="item?id=9051214">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I believe they are slightly beyond &quot;syntax sugar&quot;. If I&#x27;m mistaken, I&#x27;d love to see the equivalent of what they desugar to. Some of the nuances that I believe OCaml&#x27;s named arguments get right (and what greatly distinguishes them from passing a record) may require additional work in the type system beyond simple desugaring to something like records. Someone please correct me if I&#x27;m wrong.<p>- Partially applying arguments. You can apply one named argument, and get a function that expects the remaining named arguments. This is pretty great though confusing when you see it for the first time.<p>- Defaults for omitted arguments. If the caller doesn&#x27;t specify an argument, you can define what should be used instead. This is kind of like the opposite of subtyping on record arguments. With structurally subtyped record arguments, you can pass a record that has <i>more</i> information than a certain <i>minimum set of labeled fields</i>. But with named optional arguments with defaults, you can pass <i>less than</i> a certain <i>maximum number of labeled fields</i>.</font></span><p><font size="1"><u><a href="reply?id=9051214&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9050573" href="vote?for=9050573&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050573"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=tel">tel</a> <a href="item?id=9050573">14 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Total agreement about most of those things, but I want to indicate that Haskell has some amount of row typing available via libraries like Vinyl and it certainly has c-types.</font></span><p><font size="1"><u><a href="reply?id=9050573&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9050852" href="vote?for=9050852&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050852"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=carterschonwald">carterschonwald</a> <a href="item?id=9050852">12 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">the most recent vinyl version (0.5) <a href="https://hackage.haskell.org/package/vinyl-0.5" rel="nofollow">https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;vinyl-0.5</a>
winds up being a REALLY nice balance of flexibility, good type inference, and a few other things.<p>Its actually simple enough that for a work project I decided it would be simpler to write a custom version of the same datastructure just to avoid extra deps. (and because I needed some slightly bespoke invariants)</font></span><p><font size="1"><u><a href="reply?id=9050852&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="160"></td><td valign="top"><center><a id="up_9051101" href="vote?for=9051101&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051101"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jonsterling">jonsterling</a> <a href="item?id=9051101">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">:) Thanks! And yes, I don&#x27;t know about Anthony, but my intention has always been for Vinyl to be a proof-of-concept for what happens when you try to make a clean, minimal &amp; well-factored HList experience; my motto is, “Now build your own Vinyl”.</font></span><p><font size="1"><u><a href="reply?id=9051101&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9050641" href="vote?for=9050641&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050641"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jordwalke">jordwalke</a> <a href="item?id=9050641">13 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Thanks for reminding me. I saw a recent records proposal for Haskell that seemed to hit all the marks including performance (it wasn&#x27;t Vinyl). I seriously hope OCaml considers a similar approach to records in the future, but in the mean time, &quot;out of the box&quot; records in OCaml are sound and reasonable.</font></span><p><font size="1"><u><a href="reply?id=9050641&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050734" href="vote?for=9050734&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050734"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=vog">vog</a> <a href="item?id=9050734">13 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Also, provable performance properties are a big plus, caused by making lazy evaluation optional rather than mandatory. This aspect is explained quite well by Robert Harper:<p><a href="https://existentialtype.wordpress.com/2012/08/26/yet-another-reason-not-to-be-lazy-or-imperative/" rel="nofollow">https:&#x2F;&#x2F;existentialtype.wordpress.com&#x2F;2012&#x2F;08&#x2F;26&#x2F;yet-another...</a><p>(although he doesn&#x27;t mention OCaml, and probably has other, even better future languages, in mind)</font></span><p><font size="1"><u><a href="reply?id=9050734&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9050818" href="vote?for=9050818&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050818"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lomnakkus">lomnakkus</a> <a href="item?id=9050818">12 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Naw, Harper is SML-all-the-way (AFAICT).<p>Btw, Haskell is technically not &quot;lazy&quot;, it&#x27;s &quot;non-strict&quot;.<p>Now, I think he has a good point, but I don&#x27;t think think there&#x27;s any general consensus within the FP community which one of non-strict&#x2F;strict is &quot;better&quot;. Personally, I don&#x27;t think there&#x27;s a &quot;right&quot; answer.<p>Earlier on in my career, I would have said that &quot;non-strict&#x2F;strict&quot; should have a part of the type of a term, but after non-trivial experience with O&#x27;Caml and Lazy.t, I&#x27;m not so sure. I&#x27;m definitely sure that it lead to an absurd proliferation of incompatible interfaces.<p>And, as SPJ has opined, laziness <i>forces</i> you to be honest about side effects, which is not a trivial thing!</font></span><p><font size="1"><u><a href="reply?id=9050818&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9050902" href="vote?for=9050902&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050902"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jordwalke">jordwalke</a> <a href="item?id=9050902">12 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">One thing I find interesting, is that our industry is basically a gigantic sea full of Java&#x2F;C++ programmers.<p>Within that ocean, there is a small portion of Functional Programmers who have come to a realization that a set of finer grained abstractions would improve the industry productivity at large.<p>Within that small subset, you have a set of people who believe that static type systems aren&#x27;t ready for widespread use or are too cumbersome for expressive programming in many cases. While the other part of the functional camp are convinced that modern type systems (usually the ML variety) are more than sufficient for expressive programming.<p>Within the ML static typing camp you have people who adamantly claim that in order for static type systems to be sufficiently expressive, you must have a particular kind of polymorphism, or that this kind of polymorphism must be implicit - not explicit. Or they might form a stance along the lines of strictness vs non-strictness.<p>Then within the strictness camp, for example, some people will form a stance that your language must be formally specified (SML) as opposed to having only a reference implementation (OCaml).<p>At the end of the day, we&#x27;re left with a handful of people who share our exact opinion about what languages would <i>in theory</i> make the industry more productive.<p>Meanwhile, the enormous sea of industrial engineers are still using Java&#x2F;C++.<p>It can end up looking like people debating which particular brand of natural spring water should be given to millions of people who are thirsty in the desert.<p>I&#x27;m not sure I&#x27;m saying anything helpful, and I totally understand <i>having</i> a stance on any one of these issues. I&#x27;m not accusing anyone of being too focused on these nuances. They are important questions and I&#x27;m thankful people way more studied than I am take the time to report their findings on the tradeoffs. But personally, I also try my best to not loose sight of the fact that we are in a giant sea of people who would benefit from exploring virtually <i>any</i> of functional paradigms&#x2F;languages.</font></span><p><font size="1"><u><a href="reply?id=9050902&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="160"></td><td valign="top"><center><a id="up_9051018" href="vote?for=9051018&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051018"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=tpetricek">tpetricek</a> <a href="item?id=9051018">11 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Can I please quote your <i>debating which particular brand of natural spring water should be given to millions of people who are thirsty in the desert</i> when I get a chance :-)? It is a great summary of the problem with functional programming.<p>As a person with academic background interested in real-world FP (using F# in my case), this is exactly why I&#x27;m not very enthusiastic about most functional programming papers that appear in conferences like ICFP - they might be solving fun problems, but I&#x27;m not convinced they are problems that actually matter if we&#x27;re going to ignore the main issue.<p>I think interesting functional libraries that demonstrate how to apply FP to some interesting problem can help here - for example, the paper on financial DSLs (<a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/financial-contracts/contracts-icfp.htm" rel="nofollow">http:&#x2F;&#x2F;research.microsoft.com&#x2F;en-us&#x2F;um&#x2F;people&#x2F;simonpj&#x2F;papers...</a>) or the original paper on Functional Reactive Programming (<a href="http://conal.net/papers/icfp97/" rel="nofollow">http:&#x2F;&#x2F;conal.net&#x2F;papers&#x2F;icfp97&#x2F;</a>).</font></span><p><font size="1"><u><a href="reply?id=9051018&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="200"></td><td valign="top"><center><a id="up_9051054" href="vote?for=9051054&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051054"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jordwalke">jordwalke</a> <a href="item?id=9051054">11 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">No need to ask permission to quote me, but thanks for asking anyways. I definitely agree that shifting focus towards industrial use cases is what we need.</font></span><p><font size="1"><u><a href="reply?id=9051054&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="240"></td><td valign="top"><center><a id="up_9051296" href="vote?for=9051296&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051296"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=tpetricek">tpetricek</a> <a href="item?id=9051296">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I guess it&#x27;s more difficult than shifting the focus towards industrial use cases. Industrial use cases are a great thing, but it is something that the industry has to provide :-) (we tried to do something like that for F# here: <a href="http://manning.com/petricek2" rel="nofollow">http:&#x2F;&#x2F;manning.com&#x2F;petricek2</a> (sorry for a shameless plug!)).<p>But many people contributing to functional programming (in one way or another) are in academia. They are not the best people to contribute industrial case studies - but I think there is still a lot to be done there too! The nice thing about the FRP paper is that it is really just a fun (and very simple and somewhat impractical) example, but it is nice inspiration showing (what was back then) a novel use of functional programming. Some of the more recent academic work around FP lacks this kind of creativity...</font></span><p><font size="1"><u><a href="reply?id=9051296&amp;goto=item%3Fid%3D9050902">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="160"></td><td valign="top"><center><a id="up_9050926" href="vote?for=9050926&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050926"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lomnakkus">lomnakkus</a> <a href="item?id=9050926">12 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I won&#x27;t claim any special knowledge, nor do I have any actual <i>solid research</i> to back up my intuitions.<p>I can certainly recognize the feeling that O&#x27;Caml makes you more productive from when I first discovered it, but that was mostly just because of algebraic datatypes. (And pattern matching which, while not terribly useful in <i>general</i> circumstances, is <i>hugely</i> useful in practical CRUD-like applications.) Polymorphic variants also made the &quot;pro&quot; list.<p>The biggest boost to my productivity I&#x27;ve ever <i>felt</i>(!) was when explicitly separating different types of effects. (Not just &quot;pure vs. impure&quot;, but &quot;uses-network&quot; vs. &quot;uses-filesystem&quot; vs. &quot;pure&quot;... which is why I&#x27;m currently sticking with Haskell because it enforces that kind of discipline.<p>(I&#x27;m sure there&#x27;ll be something better coming along any day now, but...)<p>Mostly, I <i>hope</i> that problem is mostly a lack of (appropriate) advocacy and education. There&#x27;s also an absurd amount of inertia which is due to sheer entrenched interests&#x2F;industries.<p>EDIT: ... or maybe it&#x27;s a generational thing. After all this kind of thing happens in every other fast moving discipline without terribly rigorous theoretical underpinnings[1],  e.g. medicine or biology.<p>[1] Don&#x27;t get me wrong, CS is basically math which is unassailable, but we still have no idea how to (reproducibly) produce stable&#x2F;well-functioning software.</font></span><p><font size="1"><u><a href="reply?id=9050926&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="200"></td><td valign="top"><center><a id="up_9051023" href="vote?for=9051023&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051023"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ezy">ezy</a> <a href="item?id=9051023">11 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">(Note, not being critical of you, just placing this here because I was thinking about it recently)<p>Maybe because CS is so young, there is a tendency to confuse theory and practice.<p>Whether a particular language makes one more productive isn&#x27;t math, it&#x27;s engineering.  When we talk about how monads might allow you to separate concerns and relieve a mental load -- we are talking engineering.  When we talk about how monads compose, we are talking abut the math&#x2F;science that enables the engineering.  They are both related, just like mechanics is related to mechanical engineering, but they aren&#x27;t the same and they have different concerns.<p>Be wary when you start thinking in terms of &quot;entrenched interests&quot;.  It&#x27;s tempting to go down that road, but the reality is that those &quot;entrenched interests&quot; actually have good engineering reasons to be that way[1].  It isn&#x27;t like a million other programmers haven&#x27;t noticed that FP-style programming offers some benefits -- but often the benefits end up not out-weighing the drawbacks in the languages, ecosystems, and practical performance and hardware concerns.<p>This should be obvious, but I think people start muddying the waters -- especially when they focus on the ideological purity of their programming language.  Programming languages are tools.  The most popular ones are engineering tools -- and there are some not so popular ones that are tools for exploring the math behind the language itself.  There are too many tradeoffs to have a language which occupies both spheres successfully.<p>In particular, the FP advocates go round and round on this issue.  Just because something is elegant mathematically, does not mean it&#x27;s good engineering practice.  Haskell, for example, can be practical, but it struggles between the math and the reality of limited machines and human cognition[2].  Likewise, when you start talking about SML vs OCaml, you&#x27;re talking engineering, not math -- and possibly a language tailored to engineering vs math.<p>You see this in languages like C++ too, where practicality starts giving way to a kind of semi-mathematical, yet totally non-scientific, dogma about how programs should be constructed based on their respective committee-designed[3] standard libraries.<p>[1] not <i>always</i>, but more than people really give others credit for.<p>[2] I still maintain Haskell is a write-only language, like an opposing pole to perl.  Not (completely) because of the language itself, but because of the culture surrounding it which glorifies one-liner lambda calculus&#x2F;laziness tricks over engineering pragmatics.<p>[3] e.g. compromises made in absence of any real on-the-ground engineering constraints.</font></span><p><font size="1"><u><a href="reply?id=9051023&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="240"></td><td valign="top"><center><a id="up_9051933" href="vote?for=9051933&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051933"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=codygman">codygman</a> <a href="item?id=9051933">3 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">&gt; laziness tricks<p>When your language is lazy by default, is it really a trick to take advantage of that?<p>Do you consider this a trick?<p><pre><code>    take 1 [5..]
</code></pre>
How about this Fibonacci definition?<p><pre><code>    fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
</code></pre>
What about this extensible fizzbuzz example?<p><pre><code>    fizzBuzz i = if null desc then show i else desc 
        where desc = concat [label | (j,label) &lt;- tags, 0 == rem i j] 
              tags = [ (3,&quot;Fizz&quot;), (5,&quot;Buzz&quot;), (7,&quot;Baz&quot;) ]   
   
    main = mapM_ (putStrLn . fizzBuzz) [1..120]</code></pre></font></span><p><font size="1"><u><a href="reply?id=9051933&amp;goto=item%3Fid%3D9050902">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="280"></td><td valign="top"><center><a id="up_9052015" href="vote?for=9052015&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9052015"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ezy">ezy</a> <a href="item?id=9052015">2 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Focus on why you are trying to accomplish something, not how you are accomplishing it.<p>Yes, these are tricks, because &quot;lazy&quot; means you&#x27;re storing thunks and significant partial results with no outward indication of such.  Just because you don&#x27;t see it, doesn&#x27;t mean it&#x27;s not there.  I could say the same about C&#x27;s allowance of global state, or spurious use of recursion without a depth guard.<p>To your examples:<p>A trick, because who would ask for a constant from an infinite list that could be generated numerically in a fraction of the time?<p>A trick, because for random queries of large n, this is not the optimal way to compute it (the optimal way is more complex).  It also entangles memory allocation and the computation.  Note how haskell is &quot;side-effect free&quot; for fibs, yet somehow memory allocation or the time required for allocation is not considered a side-effect when I ask for &quot;fibs !! 2000000&quot;.  The C iterative solution is trivial, and will execute faster.<p>A trick, because no one cares about fizz-buzz being extensible, and this is not particularly clear to the reader compared to an ordinary if&#x2F;switch&#x2F;case expression.</font></span><p><font size="1"><u><a href="reply?id=9052015&amp;goto=item%3Fid%3D9050902">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="240"></td><td valign="top"><center><a id="up_9051098" href="vote?for=9051098&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051098"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lomnakkus">lomnakkus</a> <a href="item?id=9051098">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I won&#x27;t address all your points, but I think [1] deserves special attention: I think we can all agree that if you want to write software that will let you land a small vehicle on Mars, then you don&#x27;t want&#x2F;need the opinion of a theoretician, you just need $1B and a team of extremely disciplined programmers who will <i>ADHERE TO PROCESS</i>. Then you impose so much process that they either leave or prevail. What we&#x27;re speculating about here (at least I think we are?) is if this is a sustainable model for general development and if we can do better. Even if we can&#x27;t get better runtimes from FP languages, could we perhaps make programs which <i>generate</i> better C programs than those elite programmers that were chose for this particular mission? (I think we can. It has very little do with humans, but a lot to do with the fact that programs are very <i>meta</i> in that we can create programs that generate programs that generate programs ad-infinitum. If we can get our specifications right, the rest becomes trivial.)<p>A Mars lander program director explicitly said that he chose C because it was what he was familiar with. (I&#x27;ll edit and post a link if I can find the video.) Just for context, his decision was <i>also</i> based solely on familiarity and experience. For him it wasn&#x27;t quite so much about language, it was more about <i>process</i> (6 different industrial-strength linters, etc.)<p>&gt; Just because something is elegant mathematically, does not mean it&#x27;s good engineering practice. Haskell, for example, can be practical, but it struggles between the math and the reality of limited machines and human cognition[2]. Likewise, when you start talking about SML vs OCaml, you&#x27;re talking engineering, not math -- and possibly a language tailored to engineering vs math.<p>That&#x27;s the thing I would dispute, but it&#x27;s hard to convince people who aren&#x27;t already drinking the Kool-Aid, as it were. Compared to compiler-assisted reasoning about side-effects, the difference between SML and O&#x27;Caml is completely trivial.<p>Your [2] is just absurd :). Clearly, you don&#x27;t have to understand the body&#x2F;implementation of a function, just its type. :)<p>More seriously, I&#x27;d be interested if there&#x27;s a particular experience that soured you on FP (or perhaps Haskell, in particular)...?</font></span><p><font size="1"><u><a href="reply?id=9051098&amp;goto=item%3Fid%3D9050902">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="280"></td><td valign="top"><center><a id="up_9051919" href="vote?for=9051919&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051919"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ezy">ezy</a> <a href="item?id=9051919">3 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">&gt; What we&#x27;re speculating about here (at least I think we are?) is if this is a sustainable model for general development and if we can do better.<p>Here is the kind of difficulty I&#x27;m talking about.  Instead of thinking about this on a continuum from Aeronautics &amp; medical (where people could die) to yet another throwaway web TODO app (e.g. &quot;general dev&quot;), there is this tendency to say that they are &quot;completely different&quot; in some way.  Let&#x27;s be clear, the theories <i>do</i> help both.  Side-effect free programming is useful.  But you cannot take theory and just map it directly to the real world with no caveats.  Just because Haskell tracks side-effects, doesn&#x27;t make it superior to C in every context.<p>The Mars Rover shows this clearly -- C was chosen because someone was used to it, yes.  But the part you didn&#x27;t catch was the implicit decision that it makes no sense to use a compiler and ecosystem you don&#x27;t understand the caveats to when you need to understand all the caveats to build a successful system.<p>Similarly, the TODO app developer isn&#x27;t using Haskell because Haskell doesn&#x27;t have anywhere near the libraries Python or even Go does, and building and deploying Haskell programs is somewhat of a chore compared to those.  It&#x27;s no contest, Go is superior to Haskell.  :-)  It&#x27;s also one of the reasons almost anything is superior to C&#x2F;C++ in this very same domain. :-)  It&#x27;s not about being &quot;entrenched&quot;, because Go is way, way younger than haskell -- it&#x27;s about the priorities the language designers and developers for that language have -- ie. the culture.<p>&gt; If we can get our specifications right, the rest becomes trivial.<p>This is what I mean about theory and practice.  Note the big &quot;if&quot; there.  I totally understand the sentiment, and I wish it were true.  I even have my own meta-programming based language in the wings I&#x27;d like to release some day.<p>But the reason I&#x27;ve stalled a bit is I&#x27;ve never seen this work in practice because our minds (and specs) tend to paper over the devilish details.  I&#x27;m not saying we <i>shouldn&#x27;t</i> use meta-programming, I&#x27;m saying that it should not become dogma.  Invariably, you get caught up in details.  This kind of domain specific &quot;meta-programming&quot; is a great bootstrap technique, but doesn&#x27;t appear to be &quot;the way&quot; programs should be written.<p>The OMeta folks created a TCP stack that compiles (almost) directly from the specification.  But that was a academic exercise.  How many special cases do you think they cover?  Does anyone <i>really</i> believe that the stack in question is anything but a way to bootstrap a more robust&#x2F;performant implementation later on?<p>Similar for the PyPy folks.  Yes, you can JIT compile a python interpreter, but how many years have they worked on special cases for that, and how much farther would they have gone if they hadn&#x27;t used the meta-circular approach and just addressed the real problem to begin with[1]?<p>&gt; Compared to compiler-assisted reasoning about side-effects, the difference between SML and O&#x27;Caml is completely trivial.<p>I think as a general statement, this is true, but is a poor way of thinking about things.  You&#x27;re not comparing OCaml to SML, you&#x27;re comparing it to C++ or Java.  If all the language brings is side-effect reasoning, it&#x27;s not enough, because I can add decorators to C++ code to do what you&#x27;re asking.<p>Even with &quot;side-effect handling&quot; these languages don&#x27;t assist you with all of the side-effects someone actually cares about.  Is there a decoration for runtime speed, for memory consumption, not just for IO, but for the <i>amount</i> of IO?  Is it even predictable?  These are the real things people care about, not just whether a function peers into some global state somewhere (although that is an important thing to track, it isn&#x27;t the biggest issue, IMO).<p>&gt; Your [2] is just absurd :). Clearly, you don&#x27;t have to understand the body&#x2F;implementation of a function, just its type :)<p>Is this sarcastic? :-)  I mean, anyone with a reasonable amount of experience knows that this is not true most of the time.<p>It&#x27;s not completely false -- one doesn&#x27;t always have to look at the implementation of the operating system facilities or even the standard library.   But in code that is less than tangential to what you&#x27;re working on, you certainly do end up having to understand how it&#x27;s implemented.  As a developer, you spend more time reading code others wrote than writing it.<p>&gt; More seriously, I&#x27;d be interested if there&#x27;s a particular experience that soured you on FP (or perhaps Haskell, in particular)...?<p>I&#x27;m not soured on FP as a concept (which could mean many things, but I just mean state-awareness), just haskell.  The &lt;space&gt; fn call operator combined with currying in particular seems like an advancement to rubyists[2] and those think succinctness is a virtue above all others[4], but it is an engineering disaster -- completely unreadable at the call site unless you know the arity of every function by heart.[3]<p>But maybe I&#x27;ve just read bad code... I&#x27;m not dismissing that possibility. :-)<p>[1] The problem with python was never optimizing plain python (look at JS as an example) or the &quot;GIL&quot;, the problem was (stupid) performance requirements about the GIL from guido, and later on, C extension API compatibility.<p>[2] Do not get me started on the &quot;domain specific language&quot; shit-fest that ruby (and progenitors like groovy&#x2F;gradle) have unleashed on the world.  At least stack overflow gets money and page views from it, I guess.<p>[3] As much as people like to put down smalltalk (cum obj-c) keyword argument syntax, it is a revelation when you&#x27;re maintaining code (and I&#x27;m sorry Swift seems likely to drop it as a default).<p>[4] Is Arc (PG&#x27;s lisp) used anywhere significant, but for this website?</font></span><p><font size="1"><u><a href="reply?id=9051919&amp;goto=item%3Fid%3D9050902">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="320"></td><td valign="top"><center><a id="up_9052084" href="vote?for=9052084&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9052084"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=galaxyLogic">galaxyLogic</a> <a href="item?id=9052084">1 hour ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I agree especially about the Smalltalk-like keyword-syntax. People not used to it can&#x27;t probably appreciate the clarity it brings to code. You understand the code better - and faster - because you can understand from each calling site what each method-call does, because it can indicate the meaning of each argument clearly and concisely enough that you actually start using it for that purpose.  So to understand what a piece of code does, you mostly don&#x27;t have to look up the definition of the methods being called.<p>It takes longer to write but makes reading&#x2F;understanding much faster. When you write the code it is obvious in any language what your calls &quot;mean&quot;, but no so obvious 3 months later.<p>Writing without keyword syntax is as if all our emails just referred to &quot;him&quot; and &quot;her&quot; and &quot;they&quot; and &quot;there&quot; never mentioning the proper nouns of who or what or where are we actually talking about. It is obvious everybody understands what we are saying at the time those emails are written. But for another person or you yourself trying to understand what a specific email is actually saying would be rather difficult. Relying on the POSITION of an argument, rather than the name of it in the calling context is like saying &quot;that argument which is the 3rd&quot;.</font></span><p><font size="1"><u><a href="reply?id=9052084&amp;goto=item%3Fid%3D9050902">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="160"></td><td valign="top"><center><a id="up_9051043" href="vote?for=9051043&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051043"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=paulbutcher">paulbutcher</a> <a href="item?id=9051043">11 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I agree that this <i>was</i> the situation a while ago. But, recently, I&#x27;ve seen very encouraging signs that the wider programming community is waking up to the value of FP. Languages like Scala and Clojure, whatever else you think about them, will hopefully act as gateway drugs.</font></span><p><font size="1"><u><a href="reply?id=9051043&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050520" href="vote?for=9050520&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050520"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=amirmc">amirmc</a> <a href="item?id=9050520">14 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Toolchains also matter and OPAM (the package manager) has gone from strength to strength since this post. It&#x27;s the basis for the OCaml Platform which combines a number of useful tools and libs into a coherent workflow (making development much more productive).</font></span><p><font size="1"><u><a href="reply?id=9050520&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9050785" href="vote?for=9050785&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050785"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=more_original">more_original</a> <a href="item?id=9050785">13 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Also merlin is worth mentioning explicitly. It finds and highlights errors during editing (in emacs, vim and co), does autocompletion, shows types and since recently can also write pattern matches automatically.<p><a href="http://the-lambda-church.github.io/merlin/destruct.ogv" rel="nofollow">http:&#x2F;&#x2F;the-lambda-church.github.io&#x2F;merlin&#x2F;destruct.ogv</a></font></span><p><font size="1"><u><a href="reply?id=9050785&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051157" href="vote?for=9051157&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051157"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ufo">ufo</a> <a href="item?id=9051157">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">OPAM still doesn&#x27;t run natively on Windows though :(</font></span><p><font size="1"><u><a href="reply?id=9051157&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051221" href="vote?for=9051221&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051221"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=spyder81">spyder81</a> <a href="item?id=9051221">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I&#x27;m the author, and to be honest I agree. I was still fairly new to OCaml (and ML in general) at the time, so I tried to focus on what I knew rather than rattle off a list of things I had heard were better but didn&#x27;t really understand.</font></span><p><font size="1"><u><a href="reply?id=9051221&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050564" href="vote?for=9050564&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050564"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=tel">tel</a> <a href="item?id=9050564">14 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Haskell has subtyping, it just doesn&#x27;t use it a whole lot. That said, you can make arbitrary subtyping hierarchies using it if you like.</font></span><p><font size="1"><u><a href="reply?id=9050564&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050416" href="vote?for=9050416&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050416"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=vitriol83">vitriol83</a> <a href="item?id=9050416">15 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">IMO key advantage OCaml is easier to learn and much more pragmatic.</font></span><p><font size="1"><u><a href="reply?id=9050416&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9050903" href="vote?for=9050903&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050903"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ignoramous">ignoramous</a> <a href="item?id=9050903">12 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Unless start-ups or top companies [0] start adopting OCaml, I doubt its rise would be meteoric. Take go-lang, for example. It performs no better than Java on JVM, but is gaining tremendous traction because Google is putting all its weight behind it. I believe C# gets far less credit than it deserves... and MSFT knows exactly what its doing by open sourcing it. I digress. I feel, one is better off investing time in Clojure or Haskell (if functional programming is what one is after), both of which are gaining a lot more traction in the industry and the academia compared to OCaml.<p>I can speak from what I observed here at Amazon... which did try and make use of Erlang (due to its excellent concurrency model) at one point, but gave up (Simple DB is powered by Erlang, but its successor DynamoDB is JVM based). At least Erlang had its chance... OCaml community within Amazon is non-existent. Whereas Clojure (plenty of traction within due to STM on JVM, I guess) has plenty going for it, as does Nodejs and go-lang. All of these plaforms are popular due to the strong community presence both within the company and at other tech power houses.<p>I&#x27;d also like to point out that the current crop of volunteers behind ocaml.org [1] are doing a really great job of evangelising OCaml.<p>[0] <a href="https://ocaml.org/learn/companies.html" rel="nofollow">https:&#x2F;&#x2F;ocaml.org&#x2F;learn&#x2F;companies.html</a> and <a href="http://clojure.org/Companies" rel="nofollow">http:&#x2F;&#x2F;clojure.org&#x2F;Companies</a> and <a href="https://wiki.haskell.org/Haskell_in_industry" rel="nofollow">https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Haskell_in_industry</a><p>[1] <a href="https://ocaml.org/about.html" rel="nofollow">https:&#x2F;&#x2F;ocaml.org&#x2F;about.html</a></font></span><p><font size="1"><u><a href="reply?id=9050903&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9052207" href="vote?for=9052207&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9052207"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=danieldk">danieldk</a> <a href="item?id=9052207">7 minutes ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000"><i>Take go-lang, for example. It performs no better than Java on JVM, but is gaining tremendous traction because Google is putting all its weight behind it.</i><p>That&#x27;s definitely a large factor. But let&#x27;s not forget that Go already took off when it was barely beyond being a 20% project. Go also fills some niches, three particular ones I can think of are:<p>- People who like Java, but favor the UNIX approach of small programs over the JVM.<p>- People who like Python or Ruby, but need more performance.<p>- People who like C, but want garbage collection and some extra safety in some of their projects.<p>Add to that that Go is trivial to learn for anyone with a Java, C, or C++ background. Of course, it takes some time to learn all the idioms, but someone who knows languages with C-like syntax can start writing Go programs productively within a day.</font></span><p><font size="1"><u><a href="reply?id=9052207&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050923" href="vote?for=9050923&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050923"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=amirmc">amirmc</a> <a href="item?id=9050923">12 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">You mean top companies like, say, Facebook? Or startups like, Esper? I&#x27;m not really sure what your comment is trying to say because it comes across as circular (&#x27;they&#x27;re popular because lots of people use them&#x27;).<p>Edit: seems you&#x27;ve added the links I was about to point to.</font></span><p><font size="1"><u><a href="reply?id=9050923&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051460" href="vote?for=9051460&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051460"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=aphexairlines">aphexairlines</a> <a href="item?id=9051460">8 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">It doesn&#x27;t take much to boot up a community in a large company like Amazon or Facebook as long as it brings value.  See the FXL, Haxl, and React work at Facebook.  (I removed my comments on Amazon as it&#x27;s hard to gauge what&#x27;s ok to mention in public)</font></span><p><font size="1"><u><a href="reply?id=9051460&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9050276" href="vote?for=9050276&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050276"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=tejinderss">tejinderss</a> <a href="item?id=9050276">15 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Now that .net is going cross platform, I see a great future of f# (another variant of ML family). Its got multi processors support too.</font></span><p><font size="1"><u><a href="reply?id=9050276&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051281" href="vote?for=9051281&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051281"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lmm">lmm</a> <a href="item?id=9051281">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I think most people who wanted a cross-platform, VM-based, corporate-ecosystem-integrated ML derivative with good concurrency support have already found Scala :P.</font></span><p><font size="1"><u><a href="reply?id=9051281&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051965" href="vote?for=9051965&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051965"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=MichaelGG">MichaelGG</a> <a href="item?id=9051965">3 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I&#x27;ve looked but not touched Scala. My impressions are A: Rather verbose. B: Carries a lot more OO&#x2F;Java baggage. C: I&#x27;ve heard that the performance can be underwhelming.</font></span><p><font size="1"><u><a href="reply?id=9051965&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051477" href="vote?for=9051477&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051477"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=aphexairlines">aphexairlines</a> <a href="item?id=9051477">8 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">The problem with Scala is that you don&#x27;t just get ML -- you have to accept everything else that comes along -- so F# can be a more comfortable choice.</font></span><p><font size="1"><u><a href="reply?id=9051477&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9051553" href="vote?for=9051553&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051553"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=frowaway001">frowaway001</a> <a href="item?id=9051553">7 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">It might be easier to accept the additional parts of Scala, because the creators didn&#x27;t design them to be an tacked-on, intentionally horrible feature. (OO in F#&#x2F;OCaml anyone?)<p>Plus, sane typeclasses and higher-kinded types. :-)</font></span><p><font size="1"><u><a href="reply?id=9051553&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050333" href="vote?for=9050333&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050333"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=melling">melling</a> <a href="item?id=9050333">15 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Is there somewhere one can follow the Mac and Linux ports?  I&#x27;m stoked about F#&#x2F;OCaml too.</font></span><p><font size="1"><u><a href="reply?id=9050333&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9050495" href="vote?for=9050495&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050495"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=rdtsc">rdtsc</a> <a href="item?id=9050495">14 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Have you tried Mono and Monodevelop? I have used C# with Mono and for back-end work (non-GUI) and it works pretty well so far. I think they have F# support as well.</font></span><p><font size="1"><u><a href="reply?id=9050495&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9050727" href="vote?for=9050727&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050727"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=jfeser">jfeser</a> <a href="item?id=9050727">13 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I can confirm that MonoDevelop works reasonably well for F#, but the documentation for F# on Mono isn&#x27;t great. Coming from OCaml, I love F# as a language, but the tooling isn&#x27;t as good as it is for OCaml. Might be better on Windows with VS, but I haven&#x27;t looked closely at that.</font></span><p><font size="1"><u><a href="reply?id=9050727&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050685" href="vote?for=9050685&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050685"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=integraton">integraton</a> <a href="item?id=9050685">13 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#aeaeae">F# seems like a very nice language, but it won&#x27;t really be compelling outside of the Microsoft bubble until it&#x27;s divorced from the thick layer of Microsoft .CORP Brand Identity 2010, Visual Studio Visual Studio Visual Studio, and posts from Microsoft Outreach Engineers.<p>Compare these two Stack Overflow &quot;getting started with&quot; answers for Haskell <a href="http://stackoverflow.com/a/1016986" rel="nofollow">http:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;1016986</a> and F# <a href="http://stackoverflow.com/a/11974625" rel="nofollow">http:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;11974625</a> With the Haskell answers I don&#x27;t know or care what platforms, operating systems, editors, or IDEs they are using. With the Microsoft answer it&#x27;s like a dystopian scene filled with Branding, Branding, and more Branding.<p>Personally, I spend a lot of time experimenting with languages and ecosystems and the &quot;.NET&quot; platform is the only one where I feel the need to put on a plaid shirt and dockers with a Windows Phone on my belt and schedule a conference call with a committee at Microsoft to tell them to <i>give it a rest already.</i></font></span><p><font size="1"><u><a href="reply?id=9050685&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9050787" href="vote?for=9050787&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050787"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=BSousa">BSousa</a> <a href="item?id=9050787">13 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">mac:<p>brew install mono<p>run f# console&#x2F;repl:  fsharpi<p>compile files: fsharpc file.fs<p>Not sure about linux, but should be simple as well.<p>And as with Haskell and cabal, you have FAKE ( <a href="http://fsharp.github.io/FAKE/" rel="nofollow">http:&#x2F;&#x2F;fsharp.github.io&#x2F;FAKE&#x2F;</a> ) which isn&#x27;t exactly the same but similar<p>The main difference between those two answers is that for Haskell, the author pointed to generic Haskell resources while F# pointed to windows ones. I&#x27;ve been developing with F# for a while on the Mac and found no issues whatsoever. There is also MonoDevelop&#x2F;Xamarin if you want a more complete IDE which is better than anything I found for Haskell (but there maybe new stuff I&#x27;m missing, having messed with Haskell in a while) but SublimeText and Vim work fine.</font></span><p><font size="1"><u><a href="reply?id=9050787&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9050949" href="vote?for=9050949&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050949"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=yodsanklai">yodsanklai</a> <a href="item?id=9050949">11 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">One thing I don&#x27;t like about OCaml is that I always find myself writing the same things, like &quot;to_string&quot; functions for my variant types (although there must be some ways to alleviate this burden).<p>Also, when your programs use abstract data types you lose the benefits of pattern matching. In that case, I&#x27;m happier with languages like Go or Ada with a friendlier syntax.</font></span><p><font size="1"><u><a href="reply?id=9050949&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051062" href="vote?for=9051062&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051062"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=tel">tel</a> <a href="item?id=9051062">11 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">If you have an ADT but want pattern matching, try Scott Encoding.<p>For instance, here we have Option<p><pre><code>    module Option = struct
      let scott (some : &#x27;a -&gt; &#x27;r) 
                (none : &#x27;r) 
                (opt  : &#x27;a option) =
        match opt with
        | Some a -&gt; some a
        | None   -&gt; none
    end
</code></pre>
For Option, since it&#x27;s non-recursive, the Scott Encoding and the recursor&#x2F;inductor&#x2F;Church Encoding are identical. Here&#x27;s a linked list, though<p><pre><code>    module LL : sig
      type &#x27;a t
      val fold  : (&#x27;a -&gt; &#x27;r -&gt; &#x27;r) -&gt; &#x27;r -&gt; (&#x27;a t -&gt; &#x27;r)
      val scott : (&#x27;a -&gt; &#x27;a t -&gt; &#x27;r) -&gt; &#x27;r -&gt; (&#x27;a t -&gt; &#x27;r)
    end = struct      
      type &#x27;a t = Cons of &#x27;a * &#x27;a t | Nil
      let rec fold cons nil = function
        | Cons (h, t) -&gt; cons h (fold cons nil t)
        | Nil         -&gt; nil
      let scott cons nil = function
        | Cons (h, t) -&gt; cons h t
        | Nil         -&gt; nil
    end
</code></pre>
Anyway, the pattern should be more clear now. These provide effectively &quot;functionalized&quot; pattern matching which you can apply whenever you need. In particular, you can think of these as expressing a (potentially partial) &quot;view&quot; of the abstract type. For instance, my linked list might have not been a linked list exactly but instead some kind of tree, but `scott` and `fold` let me expose a &quot;view&quot; of that tree as though it were a linked list.</font></span><p><font size="1"><u><a href="reply?id=9051062&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051165" href="vote?for=9051165&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051165"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ufo">ufo</a> <a href="item?id=9051165">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">If you look at this from an &quot;expression problem&quot; point of view, this version with the records-of-functions is very similar to OO programming. But without inheritance, classes and so on.</font></span><p><font size="1"><u><a href="reply?id=9051165&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9051404" href="vote?for=9051404&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051404"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lpw25">lpw25</a> <a href="item?id=9051404">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Indeed classes are great for these kinds of encodings. It is one of the use cases for which classes are the nicest approach in OCaml.<p>For example, see this section of Real World OCaml:<p><a href="https://realworldocaml.org/v1/en/html/classes.html#open-recursion" rel="nofollow">https:&#x2F;&#x2F;realworldocaml.org&#x2F;v1&#x2F;en&#x2F;html&#x2F;classes.html#open-recu...</a></font></span><p><font size="1"><u><a href="reply?id=9051404&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9051385" href="vote?for=9051385&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051385"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=tel">tel</a> <a href="item?id=9051385">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I&#x27;m very much a fan of that POV. I think OO has a lot of mythology, but the technology is relatively similar to something like OCaml or Haskell. Classes are essentially just functions which return &quot;structures&quot;.<p>Inheritance and open-recursion&#x2F;dynamic binding are usually what remain. I&#x27;m not terribly sure I miss them.</font></span><p><font size="1"><u><a href="reply?id=9051385&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9052054" href="vote?for=9052054&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9052054"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=mercurial">mercurial</a> <a href="item?id=9052054">2 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">PPX lets you generate show functions automatically. As for abstract types you can use &quot;private&quot; if you need to pattern match outside the module but wont to ensure that the structure can only be created by your module.</font></span><p><font size="1"><u><a href="reply?id=9052054&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9050777" href="vote?for=9050777&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050777"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=andrewstuart">andrewstuart</a> <a href="item?id=9050777">13 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I wanted to like OCaml, mainly for working with Unikernels. When I looked at the syntax it just looked very arcane, which was discouraging.</font></span><p><font size="1"><u><a href="reply?id=9050777&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050877" href="vote?for=9050877&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050877"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ignoramous">ignoramous</a> <a href="item?id=9050877">12 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Might come handy in case you want help yourself get over the seemingly cryptic syntax: <a href="http://rigaux.org/language-study/syntax-across-languages/" rel="nofollow">http:&#x2F;&#x2F;rigaux.org&#x2F;language-study&#x2F;syntax-across-languages&#x2F;</a></font></span><p><font size="1"><u><a href="reply?id=9050877&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051170" href="vote?for=9051170&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051170"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=ufo">ufo</a> <a href="item?id=9051170">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">The syntax is certainly very wonky but you get used to it. Installing merlin (vim &#x2F; emacs plugin) helps a lot too.</font></span><p><font size="1"><u><a href="reply?id=9051170&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9050594" href="vote?for=9050594&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050594"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lmm">lmm</a> <a href="item?id=9050594">14 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">If it&#x27;s about what&#x27;s well-supported for compiling to Javascript, does scala.js becoming non-experimental change the landscape?</font></span><p><font size="1"><u><a href="reply?id=9050594&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051279" href="vote?for=9051279&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051279"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=spyder81">spyder81</a> <a href="item?id=9051279">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I knew about scala.js when writing the post (although it was still experimental at the time) but I didn&#x27;t mention it because I don&#x27;t like Scala. It looked promising when I first saw it, but then I had to write some production code in it.<p>My opinion now is that if you&#x27;re forced to use the JVM then Scala is one of the best options. But that&#x27;s a low bar, given the choice I would pick something else.</font></span><p><font size="1"><u><a href="reply?id=9051279&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9050624" href="vote?for=9050624&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050624"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=saosebastiao">saosebastiao</a> <a href="item?id=9050624">14 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Is there anywhere that I can track the status of the multicore runtime and modular implicits?</font></span><p><font size="1"><u><a href="reply?id=9050624&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9051156" href="vote?for=9051156&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051156"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lpw25">lpw25</a> <a href="item?id=9051156">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Multicore:
    <a href="https://github.com/stedolan/ocaml" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;stedolan&#x2F;ocaml</a><p>Modular implicits:
    <a href="https://github.com/ocamllabs/ocaml-modular-implicits" rel="nofollow">https:&#x2F;&#x2F;github.com&#x2F;ocamllabs&#x2F;ocaml-modular-implicits</a></font></span><p><font size="1"><u><a href="reply?id=9051156&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="0"></td><td valign="top"><center><a id="up_9050663" href="vote?for=9050663&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050663"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=wyager">wyager</a> <a href="item?id=9050663">13 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I honestly don&#x27;t get how people can claim that Haskell is unusually hard to learn. I started learning Haskell with zero functional programming experience, and after getting over that initial pure+functional learning curve (which took two or three weeks of casual learning), it was smooth sailing. Haskell is actually a very simple language compared to popular languages like  python or C++; you just have to do a bit of thinking to get out of the procedural&#x2F;imperative&#x2F;impure mindset.<p>I especially don&#x27;t understand how people get tripped up by laziness. 99.9% of strict code  will work with no changes in a lazy environment. The rest usually just needs a slight tweak to avoid memory leaks.<p>To anyone considering undertaking the modest effort required to learn Haskell, I completely recommend it. My code in every language has tangibly improved.</font></span><p><font size="1"><u><a href="reply?id=9050663&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050935" href="vote?for=9050935&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050935"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=paulrpotts">paulrpotts</a> <a href="item?id=9050935">11 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Keep in mind that writing something like this is not actually going to be perceived as helpful to most people who may have difficulty with Haskell. Consider a couple of possibilities.<p>First, you may be unusually quick, gifted, clever -- whatever you might want to call it. In this case, the new concepts in functional programming might come easy for you. That&#x27;s great, but to people for whom they don&#x27;t come so easily, this could easily be considered discouraging, or else bragging.<p>Second, consider that maybe you haven&#x27;t advanced as far in learning Haskell as you think you have. In my estimation Haskell can take you up an abstraction ramp, that has no clear and obvious &quot;end.&quot; As a research language, higher up that curve is some really mind-blowing stuff. So unless you&#x27;re SPJ or beyond, I wouldn&#x27;t be quick to claim that Haskell isn&#x27;t &quot;unusually hard to learn.&quot;<p>Third, you may be a stage in your life where you can put a lot of free time into learning, but recognize that not everyone is there. In my twenties, I worked much more than full time, and in my spare time worked on yet more programming, teaching myself other languages and environments. Really in retrospect it&#x27;s fortunate I didn&#x27;t damage my physical or mental health more than I did. But not everyone is in that boat now. In particular people who are older and have &quot;work&#x2F;life balance,&quot; who are professionals in some form of software development, may find that their employment doesn&#x27;t offer them much in the way of opportunities to learn another language, and the life part of that work&#x2F;life balance doesn&#x27;t allow much time to do so.<p>Me, I&#x27;m somewhere partway up that ramp and proud of how far I&#x27;ve come (I feel like I can use at least simple monads now) but still very aware that there is a lot I don&#x27;t fully grok (currently trying to get my mind around arrows). And I agree, I completely recommend it, but just maybe don&#x27;t be so glib to claim it is not hard.</font></span><p><font size="1"><u><a href="reply?id=9050935&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051236" href="vote?for=9051236&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051236"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=wyager">wyager</a> <a href="item?id=9051236">9 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">&gt;Keep in mind that writing something like this is not actually going to be perceived as helpful to most people who may have difficulty with Haskell<p>No, but hopefully it well help people who have yet to learn Haskell that not everyone thinks it&#x27;s particularly difficult. I&#x27;m not interested in convincing the people who&#x27;ve tried and given up on it.<p>&gt;That&#x27;s great, but to people for whom they don&#x27;t come so easily, this could easily be considered discouraging, or else bragging.<p>So what do you propose? That I pretend it&#x27;s really hard for me, even though it&#x27;s not? What effect do you think that&#x27;s going to have?<p>&gt;So unless you&#x27;re SPJ or beyond, I wouldn&#x27;t be quick to claim that Haskell isn&#x27;t &quot;unusually hard to learn.&quot;<p>You don&#x27;t have to be SPJ to learn Haskell (or talk about how hard it is). Do I have to be Stroustrup to pass judgement on how hard it is to learn C++?<p>&gt;In particular people who are older and have &quot;work&#x2F;life balance,&quot; ... and the life part of that work&#x2F;life balance doesn&#x27;t allow much time to do so.<p>I obviously don&#x27;t mean that Haskell is easy for every single person in the world to learn; I mean that, as far as languages go, it&#x27;s relatively easy enough to learn. If I didn&#x27;t have enough time to learn Haskell, I also wouldn&#x27;t have enough time to learn C++ or Python.<p>&gt; but just maybe don&#x27;t be so glib to claim it is not hard.<p>Again, what do you propose? Lie and tell people that it&#x27;s super hard, so I don&#x27;t hurt their feelings if they can&#x27;t figure it out?</font></span><p><font size="1"><u><a href="reply?id=9051236&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9051650" href="vote?for=9051650&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051650"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=swhipple"><font color="#3c963c">swhipple</font></a> <a href="item?id=9051650">6 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000"><i>So what do you propose? That I pretend it&#x27;s really hard for me, even though it&#x27;s not? What effect do you think that&#x27;s going to have?</i><p><i>Again, what do you propose? Lie and tell people that it&#x27;s super hard, so I don&#x27;t hurt their feelings if they can&#x27;t figure it out?</i><p>I don&#x27;t anybody is suggesting lying about your own personal experience with Haskell.  Rather your posts state that it was easy for you and that it should be relatively easy for everyone.<p>I think that when programmers from other languages are having trouble figuring out how to write a particular program in Haskell, whether it be due to documentation, the behavior of the code execution, or even language syntax, it doesn&#x27;t make sense to claim that it should be relatively easy for them.<p>In my (limited) experience with Haskell, there can be hang-ups that someone with experience in strictly-evaluated languages isn&#x27;t expecting. [1]<p>[1] <a href="https://wiki.haskell.org/Iteratee_I/O#The_problem_with_lazy_I.2FO" rel="nofollow">https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Iteratee_I&#x2F;O#The_problem_with_lazy_...</a></font></span><p><font size="1"><u><a href="reply?id=9051650&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9051576" href="vote?for=9051576&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051576"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=bojo">bojo</a> <a href="item?id=9051576">7 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Maybe consider a little humility first.</font></span><p><font size="1"><u><a href="reply?id=9051576&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="160"></td><td valign="top"><center><a id="up_9051677" href="vote?for=9051677&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051677"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=wyager">wyager</a> <a href="item?id=9051677">6 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#737373">Does it demonstrate a lack of humility to be honest about how difficult something was for me? I&#x27;m sorry my truthful assessment offends you. If humility means pretending things are harder than they are, then I guess I don&#x27;t have any humility.</font></span><p><font size="1"><u><a href="reply?id=9051677&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="200"></td><td valign="top"><center><a id="up_9051889" href="vote?for=9051889&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051889"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=spyder81">spyder81</a> <a href="item?id=9051889">4 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Whether we find it offensive or not isn&#x27;t relevant. Your comments are degrading to those who find it difficult, and you are actively hostile when they complain or we point this out.<p>Your attitude is one I see too often in the FP community, and well-meaning or not it holds us all back.</font></span><p><font size="1"><u><a href="reply?id=9051889&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="240"></td><td valign="top"><center><a id="up_9052006" href="vote?for=9052006&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9052006"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=wyager">wyager</a> <a href="item?id=9052006">2 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#5a5a5a">&gt;Your comments are degrading to those who find it difficult<p>Again, what do you propose I do about it? Should I never say anything positive about anything, lest I offend someone who had a bad experience?<p>&gt;Your attitude is one I see too often in the FP community<p>Which attitude is that? Optimism?</font></span><p><font size="1"><u><a href="reply?id=9052006&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="200"></td><td valign="top"><center><a id="up_9051936" href="vote?for=9051936&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051936"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=bojo">bojo</a> <a href="item?id=9051936">3 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">You seem kind of hooked up on the &quot;easy for you&quot; part, which really isn&#x27;t the part anyone cares about.  I can&#x27;t even comprehend how you came to the conclusion that you are being asked to lie.<p>Maybe a more constructive (humble?) approach would be to show others why it was easy for you, subjective as that may be, and how they can achieve faster comprehension levels based on your own experiences.</font></span><p><font size="1"><u><a href="reply?id=9051936&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050919" href="vote?for=9050919&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050919"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=mercurial">mercurial</a> <a href="item?id=9050919">12 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">The language itself is not very big. The category-theory based abstractions built on top of it, on the other hand... Just look at the lens library.</font></span><p><font size="1"><u><a href="reply?id=9050919&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051183" href="vote?for=9051183&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051183"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=wyager">wyager</a> <a href="item?id=9051183">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">That&#x27;s fair. But I don&#x27;t think it&#x27;s reasonable to lump learning about lenses (or other abstractions that aren&#x27;t part of the prelude) into learning Haskell.</font></span><p><font size="1"><u><a href="reply?id=9051183&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="120"></td><td valign="top"><center><a id="up_9051497" href="vote?for=9051497&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051497"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=aphexairlines">aphexairlines</a> <a href="item?id=9051497">8 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">Judging the ecosystem is fair in the same way that Java is lumped together with the reams of j2ee, spring, AbstractFactoryFactory sort of libraries that it yields.<p>For better or worse, switching to Haskell does entail asking yourself how hard it&#x27;ll be for your team to become comfortable with things like <a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids" rel="nofollow">http:&#x2F;&#x2F;learnyouahaskell.com&#x2F;functors-applicative-functors-an...</a></font></span><p><font size="1"><u><a href="reply?id=9051497&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="160"></td><td valign="top"><center><a id="up_9051685" href="vote?for=9051685&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051685"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=wyager">wyager</a> <a href="item?id=9051685">6 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">That&#x27;s a good point. I suppose people do judge Java by the popular Java libraries and their styles. However, I don&#x27;t really consider those things when talking about how difficult Java is to learn.<p>Learning Haskell may well be easier than using it, although the same is true for most languages.</font></span><p><font size="1"><u><a href="reply?id=9051685&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="40"></td><td valign="top"><center><a id="up_9050883" href="vote?for=9050883&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050883"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=alayne">alayne</a> <a href="item?id=9050883">12 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">From your website, you appear to be a college student. Perhaps your expectations and uses are different than commercial developers.</font></span><p><font size="1"><u><a href="reply?id=9050883&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9050945" href="vote?for=9050945&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050945"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=paulrpotts">paulrpotts</a> <a href="item?id=9050945">11 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">College students often feel at the time that they are completely overloaded with work and barely getting through (in some cases that is true, especially students who are working or non-traditional). But looking back, it is pretty clear that although I worked hard in school, I could have worked so much harder, and also that never in my life again will I be in an environment that was so _supportive_ of just learning. Not just in classes; in fact, my college experience was _especially_ supportive things learned outside of classes. And also, at 20, 21, 22 -- there are very good reasons those are the traditional college years. Our brains are just able to _soak_ up ideas so quickly at that age. They aren&#x27;t wise, they can&#x27;t necessarily integrate everything, but we are _sharp_ then! (Usually...)</font></span><p><font size="1"><u><a href="reply?id=9050945&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9050889" href="vote?for=9050889&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9050889"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=lomnakkus">lomnakkus</a> <a href="item?id=9050889">12 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">That&#x27;s a pretty sad indictment of commercial developers. Or perhaps just the pressures put on said developers :&#x2F;.</font></span><p><font size="1"><u><a href="reply?id=9050889&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr><tr><td><table border="0"><tr><td><img src="s.gif" height="1" width="80"></td><td valign="top"><center><a id="up_9051191" href="vote?for=9051191&amp;dir=up&amp;goto=item%3Fid%3D9049467"><div class="votearrow" title="upvote"></div></a><span id="down_9051191"></span></center></td><td class="default"><div style="margin-top:2px; margin-bottom:-10px; "><span class="comhead"><a href="user?id=wyager">wyager</a> <a href="item?id=9051191">10 hours ago</a> <span class="deadmark"></span></span></div><br>
<span class="comment"><font color="#000000">I am also a commercial developer; I work full-time during the summer to pay for college. My expectations don&#x27;t really change much. Of course, everyone has different expectations.</font></span><p><font size="1"><u><a href="reply?id=9051191&amp;goto=item%3Fid%3D9049467">reply</a></u></font></td></tr></table></td></tr></table><br><br>
</td></tr><tr><td><img src="s.gif" height="10" width="0"><table width="100%" cellspacing="0" cellpadding="1"><tr><td bgcolor="#ff6600"></td></tr></table><br>
<center><span class="yclinks"><a href="newsguidelines.html">Guidelines</a> | <a href="newsfaq.html">FAQ</a> | <a href="mailto:hn@ycombinator.com">Support</a> | <a href="lists">Lists</a> | <a href="bookmarklet.html">Bookmarklet</a> | <a href="dmca.html">DMCA</a> | <a href="http://www.ycombinator.com/">Y Combinator</a> | <a href="http://www.ycombinator.com/apply/">Apply</a> | <a href="mailto:hn@ycombinator.com">Contact</a></span><br><br>
<form method="get" action="//hn.algolia.com/">Search: <input type="text" name="q" value="" size="17"></form></center></td></tr></table></center></body></html>